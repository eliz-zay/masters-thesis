#include <vector>
#include <map>
#include <cmath>

#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/PassPlugin.h"
#include "llvm/Transforms/Utils/Cloning.h"

#include "BaseAnnotatedPass.cpp"

using namespace llvm;

namespace {
  class BogusSwitchPass : public BaseAnnotatedPass<BogusSwitchPass> {
  private:
    static constexpr const char *annotationName = "bogus-switch";

    const std::string flattenedSwitchAnnotation = "flatten-case-var";

    // A fraction of switch case blocks to duplicate (e.g. 0.7 means that 70% of switch blocks
    // will be duplicated and added as new cases)
    const double switchCaseTargetPart = 0.7;

    // A fraction of `store i32 caseValue, ptr %caseVar` instructions with case values of original blocks
    // to be replaced by similar instructions with case values of duplicated blocks.
    // A value is close to zero may lead to unreachable duplicated blocks (dead code)
    const double storeInstRemappingPart = 0.5;

    // Checks if the switch was annotated by control-flow flattening pass, indicating
    // that it is safe to remap cases to their duplicated versions
    bool checkIfSwitchFlattened(Function &F, SwitchInst *switchInst) const {
      auto *md = switchInst->getMetadata("annotation");
      if (!md) {
        return false;
      }

      for (auto &mdOperand : md->operands()) {
        auto *mdNode = dyn_cast<MDNode>(mdOperand);
        if (!mdNode) {
          continue;
        }

        auto *mdString = dyn_cast<MDString>(mdNode->getOperand(0));
        if (!mdString) {
          continue;
        }

        if (mdString->getString() == this->flattenedSwitchAnnotation) {
          return true;
        }
      }

      return false;
    }

    // Changes some part of `store i32 targetCaseValue, ptr %caseVar` instructions
    // to `store i32 duplicateCaseValue, ptr %caseVar` instruction.
    // Here, `caseVar` is a variable used in switch condition. `targetCaseValue` and `duplicateCaseValue` refer to
    // the original and duplicated switch case blocks respectively
    void remapCaseVarStoreInstructions(
      Function &F, Value *caseVar, ConstantInt *targetCaseValue, ConstantInt *duplicateCaseValue
    ) const {
      LLVMContext &context = F.getContext();

      std::vector<StoreInst *> storeInstructions = {};

      for (auto &block : F) {
        for (auto &instruction : block) {
          auto storeInst = dyn_cast<StoreInst>(&instruction);
          if (
            storeInst
            && storeInst->getPointerOperand() == caseVar
            && storeInst->getValueOperand() == targetCaseValue
          ) {
            storeInstructions.push_back(storeInst);
          }
        }
      }

      const int countToRemap = floor(storeInstructions.size() * this->storeInstRemappingPart);

      errs() << ", replacing " << countToRemap << " references";

      for (int i = 0; i < countToRemap; i++) {
        auto storeInst = storeInstructions[i];
        storeInst->setOperand(0, duplicateCaseValue);
      }
    }

    // Generates a unique case value for a switch, plausible if possible
    ConstantInt *generateCaseValue(LLVMContext &context, SwitchInst *switchInst) const {
      ConstantInt *caseValue = ConstantInt::get(Type::getInt32Ty(context), switchInst->getNumCases());

      // Check if there exists a case with plausible value (total number of cases)
      if (switchInst->findCaseValue(caseValue) != switchInst->case_default()) {
        // Randomize until a unique value is found
        while (switchInst->findCaseValue(caseValue) != switchInst->case_default()) {
          caseValue = ConstantInt::get(Type::getInt32Ty(context), rand());
        }
      }

      return caseValue;
    }

    // Returns switch case variable (condition) for the specific block
    Value* getSwitchCaseVar(BasicBlock &block, SwitchInst *switchInst) const {
      Value* caseVar = switchInst->getCondition();

      if (LoadInst *loadInst = dyn_cast<LoadInst>(caseVar)) {
        return loadInst->getPointerOperand();
      }

      return nullptr;
    }

    PreservedAnalyses applyPass(Function &F) const override {
      LLVMContext &context = F.getContext();

      for (auto &block : F) {
        auto switchInst = dyn_cast<SwitchInst>(block.getTerminator());
        if (!switchInst) {
          continue;
        }

        // Check if switch was generated by control-flow flattening pass
        if (!this->checkIfSwitchFlattened(F, switchInst)) {
          continue;
        }

        Value *caseVar = this->getSwitchCaseVar(block, switchInst);
        if (caseVar == nullptr) {
          errs() << "[" << BogusSwitchPass::annotationName << "] Warning: unable to identify switch variable\n";
        }

        unsigned targetCount = ceil(switchInst->getNumCases() * this->switchCaseTargetPart);

        for (
          auto switchCase = switchInst->case_begin();
          targetCount > 0;
          targetCount--, switchCase++
        ) {
          ConstantInt *targetCaseValue = switchCase->getCaseValue();
          BasicBlock *targetBlock = switchCase->getCaseSuccessor();

          ValueToValueMapTy VMap;
          BasicBlock *duplicateBlock = CloneBasicBlock(targetBlock, VMap, ".duplicate", &F);

          for (Instruction &instruction : *duplicateBlock) {
            RemapInstruction(&instruction, VMap, RF_NoModuleLevelChanges | RF_IgnoreMissingLocals);
          }

          // Add duplicated block as a switch case
          ConstantInt *duplicateCaseValue = this->generateCaseValue(context, switchInst);
          switchInst->addCase(duplicateCaseValue, duplicateBlock);

          errs() << "[" << BogusSwitchPass::annotationName << "] Generated duplicate case #"
                 << duplicateCaseValue->getValue() << " for case #" << targetCaseValue->getValue();

          // Make duplicated block reachable
          if (caseVar != nullptr) {
            this->remapCaseVarStoreInstructions(F, caseVar, targetCaseValue, duplicateCaseValue);
          }

          errs() << "\n";
        }
      }

      return PreservedAnalyses::none();
    }

  public:
    BogusSwitchPass() : BaseAnnotatedPass(BogusSwitchPass::annotationName) {}
  };
} // namespace

PassPluginLibraryInfo getBogusSwitchPassPluginInfo() {
  return {
    LLVM_PLUGIN_API_VERSION,
    "BogusSwitchPass",
    LLVM_VERSION_STRING,
    [](PassBuilder &PB) {
      PB.registerPipelineParsingCallback(
        [](
          StringRef Name,
          FunctionPassManager &FPM,
          ArrayRef<PassBuilder::PipelineElement>
        ) {
          if (Name == "bogus-switch") {
            FPM.addPass(BogusSwitchPass());
            return true;
          }
          return false;
        }
      );
    }
  };
}

extern "C" LLVM_ATTRIBUTE_WEAK PassPluginLibraryInfo llvmGetPassPluginInfo() {
  return getBogusSwitchPassPluginInfo();
}
